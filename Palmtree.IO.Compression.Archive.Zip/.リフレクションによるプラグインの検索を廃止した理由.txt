一言でいうと、「発行の際のデメリットが大きいから」。

発行の際には、オプションで単一の実行可能ファイルにまとめられたり、未使用のコードが削除されるなどの最適化が可能であるが、
これが、プラグインのような疎な結合のアセンブリ構成とは非常に相性が悪い。
例えば、完全に疎な結合のプラグインは発行の際の最適化で削除されてしまう(*1)し、
アセンブリの動的ロードや、リフレクションを使用した型オブジェクトからのインスタンス作成は、「未使用のコードの削除」を阻害する(*2)。

これは当然の話で、片方は「実行されるコードをビルドの際に完全に確定させる」思想なのに対して、もう片方は「必要なコードは実行時に動的にロードする」思想であり、
真っ向から対立している。

結果的に、「発行可能なメリットを捨てるか、プラグインの柔軟性を捨てるか」という話になる。

発行可能であることのメリットは捨てがたいので、結論としては、プラグインの動的ロードは廃止して、
どのプラグインを使うかの明示的な選択をトップレベルのアプリケーションに丸投げし、
ZIPライブラリとしてはその選択に従うことにした。

この対応により、ビルド時にどのプラグインを使うかが完全に確定するため、発行の際の恩恵を受けることが出来るようになる。


*1) プラグインというものの性質上、プラグインのクラスを明示的に参照しているコードがメインコードのどこにもない。したがって、コードの最適化が行われるとプラグインのコードが丸ごと削除されてしまう。
*2) 最適化の観点から見ると、例え未使用に見えるコードであっても動的にロードされたプラグインからは使用されるかもしれない、という可能性が常に捨てきれないので、どう見ても未使用に見えるコードであっても削除をすることが出来ない。
