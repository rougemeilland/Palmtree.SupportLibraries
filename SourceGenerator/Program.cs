using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;

namespace SourceGenerator
{
    internal partial class Program
    {
        private const byte _EAST_ASIAN_WIDTH_N = 0;
        private const byte _EAST_ASIAN_WIDTH_F = 1;
        private const byte _EAST_ASIAN_WIDTH_H = 2;
        private const byte _EAST_ASIAN_WIDTH_W = 3;
        private const byte _EAST_ASIAN_WIDTH_Na = 4;
        private const byte _EAST_ASIAN_WIDTH_A = 5;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0060:未使用のパラメーターを削除します", Justification = "<保留中>")]
        static void Main(string[] args)
        {
            var baseDirectoryPath = new FileInfo(typeof(Program).Assembly.Location).Directory?.Parent?.Parent?.Parent?.Parent ?? throw new Exception();
            if (baseDirectoryPath.Name != "Palmtree.SupportLibraries")
                throw new Exception();

            GenerateArrayExtensions(Path.Combine(baseDirectoryPath.FullName, "Palmtree.Core"));
            GenerateEastAsian(Path.Combine(baseDirectoryPath.FullName, "Palmtree.IO.Console"));

            Console.WriteLine();
            Console.Beep();
            _ = Console.ReadLine();
        }

        private static void GenerateArrayExtensions(string coreProjectPath)
        {
            var outputPath = Path.Combine(coreProjectPath, "ArrayExtensions.AutoGenerated.cs");
            if (File.Exists(outputPath))
            {
                var outputFileAttribute = File.GetAttributes(outputPath);
                File.SetAttributes(outputPath, outputFileAttribute & ~FileAttributes.ReadOnly);
            }

            try
            {
                var unmanagedTypes = new[]
                {
                    "Boolean",
                    "Char",
                    "SByte",
                    "Byte",
                    "Int16",
                    "UInt16",
                    "Int32",
                    "UInt32",
                    "Int64",
                    "UInt64",
                    "Int128",
                    "UInt128",
                    "Half",
                    "Single",
                    "Double",
                    "Decimal",
                    "IntPtr",
                    "UIntPtr",
                };
                using var sourceWriter = new StreamWriter(outputPath, false, Encoding.UTF8);
                sourceWriter.WriteLine("using System;");
                sourceWriter.WriteLine("using System.Collections.Generic;");
                sourceWriter.WriteLine("using System.Runtime.CompilerServices;");
                sourceWriter.WriteLine();
                sourceWriter.WriteLine("namespace Palmtree");
                sourceWriter.WriteLine("{");
                sourceWriter.WriteLine("    partial class ArrayExtensions");
                sourceWriter.WriteLine("    {");
                sourceWriter.WriteLine("        #region InternalQuickSort");
                #region void InternalQuickSort<ELEMENT_T>(Span<ELEMENT_T> source)
                sourceWriter.WriteLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sourceWriter.WriteLine("        private static void InternalQuickSort<ELEMENT_T>(Span<ELEMENT_T> source)");
                sourceWriter.WriteLine("            where ELEMENT_T : IComparable<ELEMENT_T>");
                sourceWriter.WriteLine("        {");
                sourceWriter.WriteLine("            if (source.Length < 2)");
                sourceWriter.WriteLine("                return;");
                foreach (var unmanagedType in unmanagedTypes)
                {
                    if (unmanagedType.EndsWith("Int128"))
                        sourceWriter.WriteLine("#if NET7_0_OR_GREATER");
                    sourceWriter.WriteLine($"            else if (typeof(ELEMENT_T) == typeof({unmanagedType}))");
                    sourceWriter.WriteLine($"                InternalQuickSortUnmanaged(ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref source.GetPinnableReference()), source.Length);");
                    if (unmanagedType.EndsWith("Int128"))
                        sourceWriter.WriteLine("#endif // NET7_0_OR_GREATER");
                }

                sourceWriter.WriteLine("            else");
                sourceWriter.WriteLine("                InternalQuickSortManaged(source);");
                sourceWriter.WriteLine("        }");
                #endregion
                sourceWriter.WriteLine("        #endregion");
                sourceWriter.WriteLine();
                sourceWriter.WriteLine("        #region InternalSequenceEqual");
                #region Boolean InternalSequenceEqual<ELEMENT_T>(ReadOnlySpan<ELEMENT_T> array1, ReadOnlySpan<ELEMENT_T> array2)
                {
                    sourceWriter.WriteLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sourceWriter.WriteLine("        private static Boolean InternalSequenceEqual<ELEMENT_T>(ReadOnlySpan<ELEMENT_T> array1, ReadOnlySpan<ELEMENT_T> array2)");
                    sourceWriter.WriteLine("            where ELEMENT_T : IEquatable<ELEMENT_T>");
                    sourceWriter.WriteLine("        {");
                    var firstElement = true;
                    foreach (var unmanagedType in unmanagedTypes)
                    {
                        if (unmanagedType.EndsWith("Int128"))
                            sourceWriter.WriteLine("#if NET7_0_OR_GREATER");
                        sourceWriter.WriteLine($"            {(firstElement ? "" : "else ")}if (typeof(ELEMENT_T) == typeof({unmanagedType}))");
                        sourceWriter.WriteLine($"                return array1.Length == array2.Length && InternalSequenceEqualUnmanaged(ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref Unsafe.AsRef(in array1.GetPinnableReference())), ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref Unsafe.AsRef(in array2.GetPinnableReference())), array1.Length);");
                        if (unmanagedType.EndsWith("Int128"))
                            sourceWriter.WriteLine("#endif // NET7_0_OR_GREATER");
                        firstElement = false;
                    }

                    sourceWriter.WriteLine("            else");
                    sourceWriter.WriteLine("                return InternalSequenceEqualManaged(array1, array2);");
                    sourceWriter.WriteLine("        }");
                }
                #endregion
                sourceWriter.WriteLine("        #endregion");
                sourceWriter.WriteLine();
                sourceWriter.WriteLine("        #region InternalSequenceCompare");
                #region Int32 InternalSequenceCompare<ELEMENT_T>(ReadOnlySpan<ELEMENT_T> array1, ReadOnlySpan<ELEMENT_T> array2)
                {
                    sourceWriter.WriteLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sourceWriter.WriteLine("        private static Int32 InternalSequenceCompare<ELEMENT_T>(ReadOnlySpan<ELEMENT_T> array1, ReadOnlySpan<ELEMENT_T> array2)");
                    sourceWriter.WriteLine("            where ELEMENT_T : IComparable<ELEMENT_T>");
                    sourceWriter.WriteLine("        {");
                    var firstElement = true;
                    foreach (var unmanagedType in unmanagedTypes)
                    {
                        if (unmanagedType.EndsWith("Int128"))
                            sourceWriter.WriteLine("#if NET7_0_OR_GREATER");
                        sourceWriter.WriteLine($"            {(firstElement ? "" : "else ")}if (typeof(ELEMENT_T) == typeof({unmanagedType}))");
                        sourceWriter.WriteLine($"                return InternalSequenceCompareUnmanaged(ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref Unsafe.AsRef(in array1.GetPinnableReference())), array1.Length, ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref Unsafe.AsRef(in array2.GetPinnableReference())), array2.Length);");
                        if (unmanagedType.EndsWith("Int128"))
                            sourceWriter.WriteLine("#endif // NET7_0_OR_GREATER");
                        firstElement = false;
                    }

                    sourceWriter.WriteLine("            else");
                    sourceWriter.WriteLine("                return InternalSequenceCompareManaged(array1, array2);");
                    sourceWriter.WriteLine("        }");
                }
                #endregion
                sourceWriter.WriteLine("        #endregion");
                sourceWriter.WriteLine("    }");
                sourceWriter.WriteLine("}");
            }
            finally
            {
                var outputFileAttribute = File.GetAttributes(outputPath);
                File.SetAttributes(outputPath, outputFileAttribute | FileAttributes.ReadOnly);
            }
        }

        private static void GenerateEastAsian(string consoleProjectPath)
        {
            var eastAsianWidthTextUrl = new Uri("https://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt");
            using (var client = new HttpClient())
            {
                var text = client.GetStringAsync(eastAsianWidthTextUrl).Result;
                var thisProjectBaseDirectory = new FileInfo(typeof(Program).Assembly.Location).Directory?.Parent?.Parent?.Parent ?? throw new Exception();
                if (thisProjectBaseDirectory.Name != "SourceGenerator")
                    throw new Exception();
                File.WriteAllText(Path.Combine(thisProjectBaseDirectory.FullName, "EastAsianWidth.txt"), text, Encoding.UTF8);
            }

            var charAttributes = new string[0x110000];
            Array.Fill(charAttributes, "N");
            Array.Fill(charAttributes, "W", 0x3400, 0x4DBF - 0x3400 + 1);
            Array.Fill(charAttributes, "W", 0x4E00, 0x9FFF - 0x4E00 + 1);
            Array.Fill(charAttributes, "W", 0xF900, 0xFAFF - 0xF900 + 1);
            Array.Fill(charAttributes, "W", 0x20000, 0x2FFFD - 0x20000 + 1);
            Array.Fill(charAttributes, "W", 0x30000, 0x3FFFD - 0x30000 + 1);

            foreach (var lineText in File.ReadLines(Path.Combine(Path.GetDirectoryName(typeof(Program).Assembly.Location) ?? throw new Exception(), "EastAsianWidth.txt")))
            {
                if (!string.IsNullOrEmpty(lineText) && !lineText.StartsWith("#", StringComparison.Ordinal))
                {
                    var match = GetEastAsianPattern().Match(lineText);
                    if (!match.Success)
                        throw new Exception();
                    var startText = match.Groups["start"].Value;
                    var offset = int.Parse(startText, NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat);
                    var type = match.Groups["type"].Value;
                    var count = 1;
                    if (match.Groups["end"].Success)
                    {
                        var endText = match.Groups["end"].Value;
                        var end = int.Parse(endText, NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat);
                        count = end - offset + 1;
                    }

                    Array.Fill(charAttributes, type, offset, count);
                }
            }

            var outputPath = Path.Combine(consoleProjectPath, "EastAsianWidth.AutoGenerated.cs");
            if (File.Exists(outputPath))
            {
                var outputFileAttribute = File.GetAttributes(outputPath);
                File.SetAttributes(outputPath, outputFileAttribute & ~FileAttributes.ReadOnly);
            }

            var languages = new[] { "ja", "ko", "vi", "zh" };

            try
            {
                using var sourceWriter = new StreamWriter(outputPath, false, Encoding.UTF8);
                sourceWriter.WriteLine("using System;");
                sourceWriter.WriteLine("using System.Collections.Generic;");
                sourceWriter.WriteLine("using System.Globalization;");
                sourceWriter.WriteLine("using System.Linq;");
                sourceWriter.WriteLine();
                sourceWriter.WriteLine("namespace Palmtree.IO.Console");
                sourceWriter.WriteLine("{");
                sourceWriter.WriteLine("    partial class EastAsianWidth");
                sourceWriter.WriteLine("    {");
                sourceWriter.WriteLine("        private static readonly  HashSet<String> _eastAsianCultureNames;");
                sourceWriter.WriteLine("        private static readonly EastAsianWidthRange[] _eastAsianWidthRanges;");
                sourceWriter.WriteLine();
                sourceWriter.WriteLine("        static EastAsianWidth()");
                sourceWriter.WriteLine("        {");
                sourceWriter.WriteLine("            var eastAsianCultureNames =");
                sourceWriter.WriteLine("                CultureInfo.GetCultures(CultureTypes.AllCultures)");
                sourceWriter.WriteLine($"                .Where(culture => {string.Join(" || ", languages.Select(language => $"culture.Name == \"{language}\" || culture.Name.StartsWith(\"{language}-\", StringComparison.OrdinalIgnoreCase)"))})");
                sourceWriter.WriteLine("                 .Select(culture => culture.Name);");
                sourceWriter.WriteLine("            _eastAsianCultureNames = new HashSet<String>(eastAsianCultureNames);");
                sourceWriter.WriteLine("            _eastAsianWidthRanges = new EastAsianWidthRange[]");
                sourceWriter.WriteLine("            {");

                for (var codePoint = 0; codePoint < charAttributes.Length;)
                {
                    var width = charAttributes[codePoint];
                    var length = 1;
                    while (codePoint + length < charAttributes.Length && width == charAttributes[codePoint + length])
                        ++length;
                    sourceWriter.WriteLine($"                new(0x{codePoint:x4}, 0x{length:x2}, EastAsianWidthType.{width}),");
                    codePoint += length;
                }

                sourceWriter.WriteLine("            };");
                sourceWriter.WriteLine("#if DEBUG");
                sourceWriter.WriteLine("            DoTest();");
                sourceWriter.WriteLine("#endif");
                sourceWriter.WriteLine("        }");
                sourceWriter.WriteLine("    }");
                sourceWriter.WriteLine("}");
            }
            finally
            {
                var outputFileAttribute = File.GetAttributes(outputPath);
                File.SetAttributes(outputPath, outputFileAttribute | FileAttributes.ReadOnly);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [GeneratedRegex("^(?<start>[\\da-fA-F]+)(..(?<end>[\\da-fA-F]+))?\\s*;\\s*(?<type>(A|F|H|N|Na|W))(\\s*#.*)?$")]
        private static partial Regex GetEastAsianPattern();
    }
}
