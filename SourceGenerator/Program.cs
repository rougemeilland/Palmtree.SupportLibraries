using System;
using System.IO;
using System.Text;

namespace SourceGenerator
{
    internal class Program
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0060:未使用のパラメーターを削除します", Justification = "<保留中>")]
        static void Main(string[] args)
        {
            var baseDirectoryPath = new FileInfo(typeof(Program).Assembly.Location).Directory?.Parent?.Parent?.Parent?.Parent ?? throw new Exception();
            if (baseDirectoryPath.Name != "Palmtree.SupportLibraries")
                throw new Exception();

            var coreProjectPath = Path.Combine(baseDirectoryPath.FullName, "Palmtree.Core");

            GenerateArrayExtensions(coreProjectPath);
        }

        private static void GenerateArrayExtensions(string coreProjectPath)
        {
            var outputPath = Path.Combine(coreProjectPath, "ArrayExtensions.AutoGenerated.cs");
            if (File.Exists(outputPath))
            {
                var outputFileAttribute = File.GetAttributes(outputPath);
                File.SetAttributes(outputPath, outputFileAttribute & ~FileAttributes.ReadOnly);
            }

            try
            {
                var unmanagedTypes = new[]
                {
                    "Boolean",
                    "Char",
                    "SByte",
                    "Byte",
                    "Int16",
                    "UInt16",
                    "Int32",
                    "UInt32",
                    "Int64",
                    "UInt64",
                    "Int128",
                    "UInt128",
                    "Half",
                    "Single",
                    "Double",
                    "Decimal",
                    "IntPtr",
                    "UIntPtr",
                };
                using var sourceWriter = new StreamWriter(outputPath, false, Encoding.UTF8);
                sourceWriter.WriteLine("using System;");
                sourceWriter.WriteLine("using System.Collections.Generic;");
                sourceWriter.WriteLine("using System.Runtime.CompilerServices;");
                sourceWriter.WriteLine();
                sourceWriter.WriteLine("namespace Palmtree");
                sourceWriter.WriteLine("{");
                sourceWriter.WriteLine("    partial class ArrayExtensions");
                sourceWriter.WriteLine("    {");
                sourceWriter.WriteLine("        #region InternalQuickSort");
                #region void InternalQuickSort<ELEMENT_T>(Span<ELEMENT_T> source)
                sourceWriter.WriteLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sourceWriter.WriteLine("        private static void InternalQuickSort<ELEMENT_T>(Span<ELEMENT_T> source)");
                sourceWriter.WriteLine("            where ELEMENT_T : IComparable<ELEMENT_T>");
                sourceWriter.WriteLine("        {");
                sourceWriter.WriteLine("            if (source.Length < 2)");
                sourceWriter.WriteLine("                return;");
                foreach (var unmanagedType in unmanagedTypes)
                {
                    if (unmanagedType.EndsWith("Int128"))
                        sourceWriter.WriteLine("#if NET7_0_OR_GREATER");
                    sourceWriter.WriteLine($"            else if (typeof(ELEMENT_T) == typeof({unmanagedType}))");
                    sourceWriter.WriteLine($"                InternalQuickSortUnmanaged(ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref source.GetPinnableReference()), source.Length);");
                    if (unmanagedType.EndsWith("Int128"))
                        sourceWriter.WriteLine("#endif // NET7_0_OR_GREATER");
                }

                sourceWriter.WriteLine("            else");
                sourceWriter.WriteLine("                InternalQuickSortManaged(source);");
                sourceWriter.WriteLine("        }");
                #endregion
                sourceWriter.WriteLine("        #endregion");
                sourceWriter.WriteLine();
                sourceWriter.WriteLine("        #region InternalSequenceEqual");
                #region Boolean InternalSequenceEqual<ELEMENT_T>(ReadOnlySpan<ELEMENT_T> array1, ReadOnlySpan<ELEMENT_T> array2)
                {
                    sourceWriter.WriteLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sourceWriter.WriteLine("        private static Boolean InternalSequenceEqual<ELEMENT_T>(ReadOnlySpan<ELEMENT_T> array1, ReadOnlySpan<ELEMENT_T> array2)");
                    sourceWriter.WriteLine("            where ELEMENT_T : IEquatable<ELEMENT_T>");
                    sourceWriter.WriteLine("        {");
                    var firstElement = true;
                    foreach (var unmanagedType in unmanagedTypes)
                    {
                        if (unmanagedType.EndsWith("Int128"))
                            sourceWriter.WriteLine("#if NET7_0_OR_GREATER");
                        sourceWriter.WriteLine($"            {(firstElement ? "" : "else ")}if (typeof(ELEMENT_T) == typeof({unmanagedType}))");
                        sourceWriter.WriteLine($"                return array1.Length == array2.Length && InternalSequenceEqualUnmanaged(ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref Unsafe.AsRef(in array1.GetPinnableReference())), ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref Unsafe.AsRef(in array2.GetPinnableReference())), array1.Length);");
                        if (unmanagedType.EndsWith("Int128"))
                            sourceWriter.WriteLine("#endif // NET7_0_OR_GREATER");
                        firstElement = false;
                    }

                    sourceWriter.WriteLine("            else");
                    sourceWriter.WriteLine("                return InternalSequenceEqualManaged(array1, array2);");
                    sourceWriter.WriteLine("        }");
                }
                #endregion
                sourceWriter.WriteLine("        #endregion");
                sourceWriter.WriteLine();
                sourceWriter.WriteLine("        #region InternalSequenceCompare");
                #region Int32 InternalSequenceCompare<ELEMENT_T>(ReadOnlySpan<ELEMENT_T> array1, ReadOnlySpan<ELEMENT_T> array2)
                {
                    sourceWriter.WriteLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sourceWriter.WriteLine("        private static Int32 InternalSequenceCompare<ELEMENT_T>(ReadOnlySpan<ELEMENT_T> array1, ReadOnlySpan<ELEMENT_T> array2)");
                    sourceWriter.WriteLine("            where ELEMENT_T : IComparable<ELEMENT_T>");
                    sourceWriter.WriteLine("        {");
                    var firstElement = true;
                    foreach (var unmanagedType in unmanagedTypes)
                    {
                        if (unmanagedType.EndsWith("Int128"))
                            sourceWriter.WriteLine("#if NET7_0_OR_GREATER");
                        sourceWriter.WriteLine($"            {(firstElement ? "" : "else ")}if (typeof(ELEMENT_T) == typeof({unmanagedType}))");
                        sourceWriter.WriteLine($"                return InternalSequenceCompareUnmanaged(ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref Unsafe.AsRef(in array1.GetPinnableReference())), array1.Length, ref Unsafe.As<ELEMENT_T, {unmanagedType}>(ref Unsafe.AsRef(in array2.GetPinnableReference())), array2.Length);");
                        if (unmanagedType.EndsWith("Int128"))
                            sourceWriter.WriteLine("#endif // NET7_0_OR_GREATER");
                        firstElement = false;
                    }

                    sourceWriter.WriteLine("            else");
                    sourceWriter.WriteLine("                return InternalSequenceCompareManaged(array1, array2);");
                    sourceWriter.WriteLine("        }");
                }
                #endregion
                sourceWriter.WriteLine("        #endregion");
                sourceWriter.WriteLine("    }");
                sourceWriter.WriteLine("}");
            }
            finally
            {
                var outputFileAttribute = File.GetAttributes(outputPath);
                File.SetAttributes(outputPath, outputFileAttribute | FileAttributes.ReadOnly);
            }
        }
    }
}
